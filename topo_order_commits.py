#Tasks in this script
#1: Discover the .git directory
#2: Get the list of local branch name
#3: Build the commit graph
#4: Generate a topological ordering of the commits in the graph
#5: Print the commit hashes in the order generated by the previous step, from the least to the greatest
import os, sys, zlib

#given representation of a commit
class CommitNode:
  def __init__(self, commit_hash): 
    """
    :type commit_hash: str
    """
    self.commit_hash = commit_hash
    self.parents = set()
    self.children = set()
    self.visited = 0  #For depth-first search. 0 will represent unvisted, 1 represents temp mark, 2 represents visited

#2 helper function
def grab_branch_names(target_dir):
    branches = list()
    current_files = os.listdir(target_dir)  #get files in current directory
    for files in current_files:
      target = os.path.join(target_dir, files) #get file or directory 
      if os.path.isfile(target): #directory or file?
          branches.append(target) #file
      else:
          branches = branches + grab_branch_names(target_dir) #recursively search through directory
    return branches

#3 helper function
def generate_commit_graph(nodes, parent, child, directory):  
  if (parent in nodes):  #base case
    return
  
  commit_node = CommitNode(parent) #create node using given class

  if (child != None):  #add children
    commit_node.children.add(child)
  
  nodes[parent] = commit_node #map commit ID to commit info

  first_two_digits = parent[0:2]
  remaining = parent[2:40]
  file = open(directory + "/" + first_two_digits + "/" + remaining, 'rb') #first 2 digits are directory then remaining 38 are the actual file
  commit_info = zlib.decompress(file.read()) #decompress commit info 
  file.close()

  num = 0
  while True: #find parents, if any
    find_parent = commit_info.find(b"parent", num) #find method returns the index of the beginning of the substring if found, otherwise -1 is returned.  b is empty bytes literal
    num = find_parent + 48 #prevent repetition of parents
    if (find_parent == -1): 
      break
    parent_commit = commit_info[find_parent + 7 : find_parent + 48] #parent commit is 7 indexes after "parent" string, and is 40 characters long
    commit_node.parents.add(parent_commit.decode('ascii'))  #add parent

  for node in commit_node.parents: #depth first search the parents to conitue working down DAG
    visited = False
    visited_node = None
    if node in nodes:  #if node in nodes, then its already been visted
      visited_node = nodes[node]
      visited = True
    if visited: 
      visited_node.children.add(parent)  #parent is the child of its parent
    else: 
      generate_commit_graph(nodes, node, parent, directory) #recursion 

#4 helper function      
#topological sort algorithm based on depth-first search. Following algorithm on wikipedia
def topological_sort(ordered_nodes, node, nodes):
  if (nodes[node].visited == 2): #2 represents visited
    return
  
  if (nodes[node].visited == 1): #1 represents temp mark
    sys.stderr.write("Not a DAG")
    sys.exit(1)

  nodes[node].visited = 1; #mark with temp mark

  for child in nodes[node].children: #for each of node's children
    topological_sort(ordered_nodes, child, nodes) #recursive call

  nodes[node].visited = 2; #mark with temp mark
  ordered_nodes.append(nodes[node]) #append node to end 


#implementation
def topo_order_commits():
  #1:
  current_directory = os.getcwd()  #get directory you're currently in
  
  while True:
    if os.path.isdir(current_directory + "/.git"): #check if .git is in current directory
      break
    else: 
      parent_directory = os.path.dirname(current_directory) #otherwise get parent directory
      if (parent_directory == current_directory): #check if at root
        sys.stderr.write("Not inside a Git repository")
        sys.exit(1)
      else: #otherwise iterate up to parent directory
        current_directory = parent_directory
  
 
  #2:
  target_dir = (current_directory + "/.git/refs/heads") #branches map to refs/heads
  branch_names = grab_branch_names(target_dir)

  for i in range(0, len(branch_names)):  #get rid of file path and store just names of branches
    temp = branch_names[i].find("/.git/refs/heads/") + 17
    branch_names[i] = branch_names[i][temp:]
 

  #3:
  nodes = dict() #maps commit ID to commit string
  git_objects = (current_directory + "/.git/objects")
  file_path = current_directory + '/.git/refs/heads/'

  branch_names.sort() 
  for branch in branch_names:
    curr_file = open(file_path + branch, "r") 
    commit = curr_file.read() #read each branch
    curr_file.close()
    generate_commit_graph(nodes, commit, None, git_objects)


  #4:
  ordered_nodes = list()
  for node in nodes:
    topological_sort(ordered_nodes, node, nodes)

  
  #5:
  is_sticky = False

  branch_heads = dict()
  for branch in branch_names:  #get branches for output
    curr_file = open(file_path + branch, "r") 
    commit = curr_file.read() #read each branch
    if (commit not in branch_heads): #check if commit already mapped to
      branch_heads[commit] = list() #create new mapping
      branch_heads[commit].append(branch) #commit is key, branch is value

  ordered_length = len(ordered_nodes)
  for i in range(0, ordered_length):
    node = ordered_nodes[i].commit_hash[:-1] #[:-1] omits last character 

    if (ordered_nodes[i].commit_hash in branch_heads): #check if commit is head of a branch
      for branch in branch_heads[ordered_nodes[i].commit_hash]: #names of branches
        node = node + " " + branch

    if is_sticky: #sticky start?
      is_sticky = False
      sticky = ""
      for child in ordered_nodes[i].children:
        sticky += child[:-1] + " "   
      print("=" + sticky[:-1]) #print children
      print(node) 
    elif (i < ordered_length - 1 and (ordered_nodes[i + 1].commit_hash not in ordered_nodes[i].parents)): #sticky end?
      is_sticky = True
      print(node)
      sticky_end = ""
      for parent in ordered_nodes[i].parents: #print parents 
        sticky_end += parent[:-1] + " "
      print(sticky_end[:-1] + "=\n")
    else: #not an edge case
      print(node)

if __name__ == '__main__':
    topo_order_commits()